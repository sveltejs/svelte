import * as fs from 'node:fs';
import * as path from 'node:path';
import * as svelte from 'svelte/compiler';
import { assert, describe, it } from 'vitest';
import { try_load_config } from '../helpers.js';
// keep source-map at version 0.7.x
// https://github.com/mozilla/source-map/issues/400
import { getLocator } from 'locate-character';
import { SourceMapConsumer } from 'source-map';

describe('sourcemaps', async () => {
	await Promise.all(fs.readdirSync(`${__dirname}/samples`).map((dir) => run(dir)));

	async function run(dir) {
		if (dir[0] === '.') return;

		const config = await try_load_config(`${__dirname}/samples/${dir}/_config.js`);

		// add .solo to a sample directory name to only run that test
		const solo = config.solo || /\.solo/.test(dir);
		const skip = config.skip || /\.skip/.test(dir);

		const it_fn = solo ? it.only : skip ? it.skip : it;

		it_fn(dir, async () => {
			const { test } = await import(`./samples/${dir}/test.js`);

			const input_file = path.resolve(`${__dirname}/samples/${dir}/input.svelte`);
			const output_name = '_actual';
			const output_base = path.resolve(`${__dirname}/samples/${dir}/${output_name}`);

			const input_code = fs.readFileSync(input_file, 'utf-8');
			const input = {
				code: input_code,
				locate: getLocator(input_code),
				locate_1: getLocator(input_code, { offsetLine: 1 })
			};
			const preprocessed = await svelte.preprocess(
				input.code,
				config.preprocess || {},
				config.options || {
					filename: 'input.svelte'
				}
			);
			const { js, css } = svelte.compile(preprocessed.code, {
				filename: 'input.svelte',
				// filenames for sourcemaps
				sourcemap: preprocessed.map,
				outputFilename: `${output_name}.js`,
				cssOutputFilename: `${output_name}.css`,
				...(config.compile_options || {})
			});

			js.code = js.code.replace(/generated by Svelte v\d+\.\d+\.\d+/, (match) =>
				match.replace(/\d/g, 'x')
			);

			fs.writeFileSync(`${output_base}.svelte`, preprocessed.code);
			if (preprocessed.map) {
				fs.writeFileSync(
					`${output_base}.svelte.map`,
					// TODO encode mappings for output - svelte.preprocess returns decoded mappings
					JSON.stringify(preprocessed.map, null, 2)
				);
			}
			fs.writeFileSync(
				`${output_base}.js`,
				`${js.code}\n//# sourceMappingURL=${output_name}.js.map`
			);
			fs.writeFileSync(`${output_base}.js.map`, JSON.stringify(js.map, null, 2));
			if (css.code) {
				fs.writeFileSync(
					`${output_base}.css`,
					`${css.code}\n/*# sourceMappingURL=${output_name}.css.map */`
				);
				fs.writeFileSync(`${output_base}.css.map`, JSON.stringify(css.map, null, '  '));
			}

			if (js.map) {
				assert.deepEqual(
					js.map.sources.slice().sort(),
					(config.js_map_sources || ['input.svelte']).sort(),
					'js.map.sources is wrong'
				);
			}
			if (css.map) {
				assert.deepEqual(
					css.map.sources.slice().sort(),
					(config.css_map_sources || ['input.svelte']).sort(),
					'css.map.sources is wrong'
				);
			}

			// use locate_1 with mapConsumer:
			// lines are one-based, columns are zero-based

			preprocessed.mapConsumer =
				preprocessed.map && (await new SourceMapConsumer(preprocessed.map));
			preprocessed.locate = getLocator(preprocessed.code);
			preprocessed.locate_1 = getLocator(preprocessed.code, { offsetLine: 1 });

			js.mapConsumer = js.map && (await new SourceMapConsumer(js.map));
			js.locate = getLocator(js.code);
			js.locate_1 = getLocator(js.code, { offsetLine: 1 });

			css.mapConsumer = css.map && (await new SourceMapConsumer(css.map));
			css.locate = getLocator(css.code || '');
			css.locate_1 = getLocator(css.code || '', { offsetLine: 1 });

			await test({ assert, input, preprocessed, js, css });
		});
	}
});
