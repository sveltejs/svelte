<!doctype html>
<html>
	<head>
		<style>
			body {
				--bg-1: hsl(0, 0%, 100%);
				--bg-2: hsl(206, 20%, 90%);
				--bg-3: hsl(206, 20%, 80%);
				--fg-1: hsl(0, 0%, 13%);
				--fg-2: hsl(0, 0%, 20%);
				--fg-2: hsl(0, 0%, 30%);
				--link: hsl(208, 77%, 47%);
				--link-hover: hsl(208, 77%, 55%);
				--link-active: hsl(208, 77%, 40%);
				--border-radius: 4px;
				--font: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,
					'Open Sans', 'Helvetica Neue', sans-serif;
				--font-mono: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Consolas,
					'DejaVu Sans Mono', monospace;
				color-scheme: light;
				background: var(--bg-1);
				color: var(--fg-1);
				font-family: var(--font);
				line-height: 1.5;
				margin: 1rem;
				height: calc(100vh - 2rem);
				accent-color: var(--hover) !important;
			}

			a {
				color: var(--link);
			}

			a:hover {
				color: var(--link-hover);
			}

			a:active {
				color: var(--link-active);
			}

			code {
				background: var(--bg-2);
				font-family: var(--font-mono);
				font-size: 0.9em;
				padding: 0.15rem 0.3rem;
				border-radius: var(--border-radius);
			}

			ul.todos {
				padding: 0;
			}

			body.dark {
				color-scheme: dark;
				--bg-1: hsl(0, 0%, 18%);
				--bg-2: hsl(0, 0%, 30%);
				--bg-3: hsl(0, 0%, 40%);
				--fg-1: hsl(0, 0%, 90%);
				--fg-2: hsl(0, 0%, 70%);
				--fg-3: hsl(0, 0%, 60%);
				--link: hsl(206, 96%, 72%);
				--link-hover: hsl(206, 96%, 78%);
				--link-active: hsl(206, 96%, 64%);
			}
		</style>

		<script>
			(function () {
				function send(payload, origin = '*') {
					parent.postMessage(payload, origin);
				}

				window.addEventListener('message', ({ origin, data }) => {
					let { action, cmd_id } = data;

					const reply = (payload) => send({ ...payload, cmd_id }, origin);

					try {
						if (action === 'set_theme') {
							document.body.classList.toggle('dark', data.args.theme === 'dark');
						}

						if (action === 'eval') {
							(0, eval)(data.args.script);
						}

						if (action === 'catch_clicks') {
							document.body.addEventListener('click', (event) => {
								if (event.which !== 1) return;
								if (event.metaKey || event.ctrlKey || event.shiftKey) return;
								if (event.defaultPrevented) return;

								// ensure target is a link
								let el = event.target;
								while (el && el.nodeName !== 'A') el = el.parentNode;
								if (!el || el.nodeName !== 'A') return;

								if (
									el.hasAttribute('download') ||
									el.getAttribute('rel') === 'external' ||
									el.target
								)
									return;

								event.preventDefault();

								if (el.href.startsWith(origin)) {
									const url = new URL(el.href);
									if (url.hash[0] === '#') {
										window.location.hash = url.hash;
										return;
									}
								}

								window.open(el.href, '_blank');
							});
						}

						reply({ action: 'cmd_ok' });
					} catch ({ message, stack }) {
						reply({ action: 'cmd_error', message, stack });
					}
				});

				window.onerror = function (msg, url, lineNo, columnNo, error) {
					send({ action: 'error', value: error });
				};

				window.addEventListener('unhandledrejection', (event) => {
					send({ action: 'unhandledrejection', value: event.reason });
				});

				function intercept(method, fn) {
					const original = console[method];
					console[method] = (...args) => {
						fn(...args);
						original(...args);
					};
				}

				const timers = new Map();
				const counters = new Map();

				const simple = ['log', 'info', 'dir', 'warn', 'error'];
				const commands = [...simple, 'clear', 'group', 'groupEnd', 'groupCollapsed'];

				let previous = '';

				for (const level of commands) {
					intercept(level, (...args) => {
						const can_duplicate =
							simple.includes(level) &&
							args.every(
								(arg) => arg === null || (typeof arg !== 'object' && typeof arg !== 'function')
							);

						if (previous === (previous = stringify({ level, args })) && can_duplicate) {
							send({ action: 'console', level, duplicate: true });
						} else {
							try {
								send({ action: 'console', level, args });
							} catch (err) {
								send({ action: 'console', level: 'unclonable' });
							}
						}
					});
				}

				intercept('table', (...args) => {
					const value = args[0];
					if (value && typeof value === 'object') {
						send({ action: 'console', level: 'table', args });
					} else {
						send({ action: 'console', level: 'log', args });
					}
				});

				intercept('time', (label = 'default') => {
					timers.set(label, performance.now());
				});

				intercept('timeLog', (label = 'default') => {
					const now = performance.now();
					if (timers.has(label)) {
						send({
							action: 'console',
							level: 'system-log',
							args: [`${label}: ${now - timers.get(label)}ms`]
						});
					} else {
						send({
							action: 'console',
							level: 'system-warn',
							args: [`Timer '${label}' does not exist`]
						});
					}
				});

				intercept('timeEnd', (label = 'default') => {
					const now = performance.now();
					if (timers.has(label)) {
						send({
							action: 'console',
							level: 'system-log',
							args: [`${label}: ${now - timers.get(label)}ms`]
						});
					} else {
						send({
							action: 'console',
							level: 'system-warn',
							args: [`Timer '${label}' does not exist`]
						});
					}
					timers.delete(label);
				});

				intercept('assert', (condition, ...args) => {
					if (condition) return;
					const stack = new Error().stack;
					send({ action: 'console', level: 'assert', args, stack });
				});

				intercept('count', (label = 'default') => {
					counters.set(label, (counters.get(label) || 0) + 1);
					send({
						action: 'console',
						level: 'system-log',
						args: [`${label}: ${counters.get(label)}`]
					});
				});

				intercept('countReset', (label = 'default') => {
					if (counters.has(label)) {
						counters.set(label, 0);
					} else {
						send({
							action: 'console',
							level: 'system-warn',
							args: [`Count for '${label}' does not exist`]
						});
					}
				});

				intercept('trace', (...args) => {
					const stack = new Error().stack;
					send({ action: 'console', level: 'trace', args, stack });
				});

				function stringify(args) {
					try {
						return JSON.stringify(args, (key, value) => {
							// if we don't do this, our Set/Map from svelte/reactivity would show up wrong in the console
							if (value instanceof Map) {
								return { type: 'Map', value };
							}

							if (value instanceof Set) {
								return { type: 'Set', value };
							}

							return value;
						});
					} catch (error) {
						return null;
					}
				}
			})();
		</script>
	</head>
	<body></body>
</html>
